import lookml_gen as l 
import datetime as dt
import api as api
import pprint as pp

OUTPUT_DIR = '/Users/hugoselbie/looker_stuff/code_sample/py/autogen_testing/join2019_demo/LookMLWriteOutput/'

###
# Creating connection to the looker instance to make api calls against the sql_runner
connection = api.lookerAPIClient()

pdthash = 'profservices_scratch.LR$H2W42B5EBFK26PU9ZQJHE_base_eav_data'

###
# SQL to run against sql_runner, assuming we're doing an information_schema scan to generate tables
sql = f'SELECT * FROM {pdthash} AS base_eav_data'

###
# API method to run above sql aginst the inputted connection
view_data = connection.run_sql(sql, 'thelook_events_redshift')

###
# Amending column names to add underscores in case they don't exist
column_names = list(set([names ['column_name'] for names in view_data]))
amended_column_names = [name.replace(" ", "_") for name in column_names]

###
# Printing out the sql transformation from the api JSON response for addition into derived table LookML
select_clause = []
for row in column_names:
    tmp_field = f', MAX(CASE WHEN EAV_data.column_name = \'{row}\' THEN EAV_data.column_value ELSE null END) AS \"{row}\"'
    select_clause.append(tmp_field)
select_clause = '\n'.join(select_clause)
sql = f'''
SELECT
    EAV_data.schema_id
    , EAV_data.entity_id
    {select_clause}
FROM {pdthash} as EAV_data
        GROUP BY 1,2
'''
# pp.pprint(view_data)

tmp_view = l.View('example_derived_volatile', derived_table = {'sql':sql}).setFolder(OUTPUT_DIR)
tmp_view + 'schema_id' + 'entity_id'
tmp_view.setExtensionRequired()
tmp_view.setMessage('This is an autogenerated view created by python at '+str(dt.datetime.now().replace(microsecond=0).isoformat()))
###
# Iterating over teh api response and adding syntactically correct Dimensions with appropriate access grants to prevent multi tenant data views
for data in view_data:
    entity_id = data['entity_id']
    if data['data_type'] == 'numerical' or data['data_type'] == 'decimal':
        dim = l.Dimension(data['column_name'])
        dim.setType('number')
        dim.hide()
        dim.set_Field_Level_Permission(f'eid_{entity_id}')
        tmp_view + dim

    else:
        dim = l.Dimension(data['column_name'])
        dim.set_Field_Level_Permission(f'eid_{entity_id}')
        dim.setType('string')
        dim.hide()
        tmp_view + dim
###
# Adding a series of measures of type sum with field level permissioning
    measure = l.Measure('total_'+data['column_name']).setProperty('sql','${'+data['column_name']+'}').setType('sum')
    measure.set_Field_Level_Permission(f'eid_{entity_id}')
    tmp_view + measure

# tmp_view.write()

eidAccessGrants = list(set([data['entity_id'] for data in view_data]))
tmp_model = l.Model('access_grant_model')
tmp_model.setConnection('thelook_events_redshift')

explore = l.Explore('test')

for grant in eidAccessGrants:
    field = l.Field_Level_Permissions(grant)
    field.set_User_Attribute('entity_id')
    field.set_Allowed_Value(grant)
    tmp_model.addAccessGrant(field)

print(tmp_model)